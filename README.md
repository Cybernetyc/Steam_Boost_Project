# Steam Boost Projet — прошивка контроллера системы принудительного полива в парной. 

## Назначение

Проект для **STM32F401CCU6 (Cortex‑M4F)**, который:
- управляет **3‑разрядным 7‑сегментным индикатором** в режиме динамической индикации (мультиплекс) через **TIM3 IRQ** (частота задаётся PSC/ARR и деревом тактирования);
- реализует простую **машину состояний** для режима *готовность → обратный отсчёт → конфигурация*;
- обрабатывает **кнопку** с программным антидребезгом и событиями *SHORT / LONG*;
- сохраняет параметр `cfg_sec` во **Flash** (сектор 5) с валидацией (magic/version + инверсная копия поля).
- включает, отключает клапан подачи жидкости

## Аппаратная платформа

- MCU: **STM32F401CCU6** (UFQFPN48) (с возможностью перехода на более младшую модель, для уменьшение издержек производства)
- Прошивка собрана под **HAL** (STM32CubeF4), но драйвер индикатора использует прямой доступ к регистрам GPIO (BSRR/ODR).
- Отладка/прошивка: **ST‑LINK (SWD)**.

## Подключение (GPIO)

Пины взяты из `Core/Inc/main.h` и `7_Seg.ioc`.

| Назначение | Метка | Порт/пин |
|---|---:|---|
| Сегменты индикатора | A..G | PA0..PA6 |
| Точка (DP) | P | PA7 |
| Разряды (ключи) | Q1, Q2, Q3 | PB0, PB1, PB2 |
| Кнопка | K1 | PB10 (в проекте `PULLDOWN`, активный уровень **HIGH**) |
| Клапан/выход | VALVE | PB12 (**активный LOW**: `RESET` = OPEN, `SET` = CLOSED) |

⚠️ Важно: отображение цифр зависит от разводки сегментов/ключей. В `Core/Src/7_seg_driver.c` таблица `digits_code[]` задаёт паттерны сегментов; при другой распиновке/логике может понадобиться корректировка.

## Логика работы

### Динамическая индикация (TIM3)

- Таймер **TIM3** используется как тик мультиплекса (`Prescaler=8399`, `Period=9`).
  Фактическая частота зависит от тактирования APB1.
  В текущей конфигурации (`SYSCLK=80 МГц`, `AHB=/4`, `APB1=/2` → `TIM3CLK≈20 МГц`) получается примерно:
  `f_irq = 20_000_000 / (8399+1) / (9+1) ≈ 238.1 Гц` (≈79 Гц на разряд).
  Если нужна более высокая частота/яркость — измените PSC/ARR или конфигурацию тактирования.
- В `HAL_TIM_PeriodElapsedCallback()` вызывается `Seg7_UpdateIndicator(&seg7_handle)`, которая:
  - гасит все разряды (Q1..Q3),
  - выставляет сегменты на порту A (PA0..PA7),
  - включает текущий разряд,
  - переключает `current_digit` по кругу.

### Машина состояний

Файл: `Core/Src/State_Machine.c`

Состояния:
- `STATE_READY` — ожидание. На индикаторе отображается `cfg_sec`.
- `STATE_COUNTDOWN` — обратный отсчёт. На индикаторе отображается `cur_sec`.
- `STATE_CONFIG` — конфигурация. На индикаторе отображается редактируемое значение, **включается DP** в правом разряде.

События:
- `EVENT_BTN_SHRT_PRESS` — короткое нажатие (формируется **на отпускании**, если не было LONG).
- `EVENT_BTN_LONG_PRESS` — длинное (формируется по порогу).
- `EVENT_TICK_1S` — тик 1 секунда.

Поведение (как реализовано в коде):
- **READY**
  - SHORT → переход в COUNTDOWN, `cur_sec = cfg_sec`, клапан **OPEN**
  - LONG  → переход в CONFIG, редактирование начиная с текущего `cfg_sec`
- **COUNTDOWN**
  - SHORT → отмена, переход в READY, клапан **CLOSED**
  - TICK_1S → `cur_sec--`, при достижении 0 клапан закрывается; затем автомат возвращается в READY
- **CONFIG**
  - SHORT → циклически меняет значение (`cfg_next_3_6()`)
  - LONG  → если значение изменилось — сохраняет во Flash (`APP_Save_CFG_Flash()`), затем переход в READY

### Кнопка

Файл: `Core/Src/Button.c`

- Опрос должен выполняться **строго раз в 1 мс** (в `main.c` сделан “догоняющий” цикл по `HAL_GetTick()`).
- Антидребезг: `BTN_DEBOUNCE_MS = 20`.
- Длинное нажатие: `BTN_LONG_MS = 1000` (событие генерируется **один раз** за удержание).
- SHORT генерируется при **стабильном отпускании**, если LONG в этом удержании не был сгенерирован.

## Flash‑конфигурация

Файлы: `Core/Src/AppFlashConfig.c`, `Core/Inc/AppFlashConfig.h`

- Конфиг хранится в **секторе 5** по адресу `0x08020000` (`FLASH_SECTOR_5`).
- Структура `AppFlashConfig_t` содержит:
  - `magic = 0x0BADC0DE`
  - `version = 1`
  - `cfg_sec` и `cfg_sec_inv = ~cfg_sec`
  - `reserved_1/2`
- При старте вызывается `APP_Load_CFG_Flash()`:
  - если данные валидны — копируются в `GlobalAppConfig`
  - иначе — записываются значения по умолчанию
- При сохранении:
  - проверяется необходимость записи (memcmp с текущими Flash‑данными),
  - на время erase/program останавливается TIM3 IRQ и запрещаются прерывания,
  - выполняется erase сектора и запись “словами”,
  - в конце выполняется проверка валидности.

⚠️ Важная деталь линковки: в `STM32F401XX_FLASH.ld` регион `FLASH` задан как **128K** (хотя MCU имеет 256K). Это сделано, чтобы **зарезервировать сектор 5 под конфиг** и не позволить линкеру размещать туда код.

## Структура проекта

- `Core/Src/`
  - `main.c` — инициализация, суперцикл, 1 мс опрос кнопки, 1 сек тик автомата, TIM3 callback
  - `7_seg_driver.c` — драйвер индикатора (буфер разрядов, DP, мультиплекс)
  - `State_Machine.c` — машина состояний
  - `Button.c` — кнопка: debounce + SHORT/LONG
  - `AppFlashConfig.c` — сохранение/загрузка конфига во Flash
- `Core/Inc/` — заголовки модулей
- `Drivers/` — STM32CubeF4 HAL + CMSIS
- `7_Seg.ioc` — конфигурация STM32CubeMX
- `CMakeLists.txt`, `cmake/`, `CMakePresets.json` — сборка через CMake (arm-none-eabi)

## Сборка (CMake)

### Требования
- CMake **>= 3.22**
- Ninja
- ARM GCC toolchain (`arm-none-eabi-gcc`)  
  (или **STM32CubeCLT**, где toolchain обычно уже включён)
- (опционально) STM32CubeMX для регенерации кода из `.ioc`

### Команды
```bash
# Debug
cmake --preset Debug
cmake --build --preset Debug

# Release
cmake --preset Release
cmake --build --preset Release
```

Результат сборки по пресетам по умолчанию: `build/Debug/7_Seg.elf` или `build/Release/7_Seg.elf`.

> Если нужен `.hex` / `.bin`, можно сделать вручную:
> ```bash
> arm-none-eabi-objcopy -O ihex  build/Debug/7_Seg.elf build/Debug/7_Seg.hex
> arm-none-eabi-objcopy -O binary build/Debug/7_Seg.elf build/Debug/7_Seg.bin
> ```

## Прошивка и отладка

- Рекомендуемый путь: **STM32CubeProgrammer** (GUI или CLI) + **ST‑LINK**.
- Для CLion в проекте присутствуют настройки debug‑server под **STM32CubeCLT / ST‑LINK gdbserver** (`.idea/debugServers/ST_LINK.xml`).  
  Путь к `ST-LINK_gdbserver.exe` в конфиге **локальный** (Windows) — его нужно будет адаптировать под вашу установку.

## Лицензии

- Код HAL/CMSIS из `Drivers/` распространяется по лицензиям ST (см. файлы `LICENSE.txt` внутри соответствующих директорий).
- Для пользовательских модулей (`7_seg_driver`, `State_Machine`, `Button`, `AppFlashConfig`) явная лицензия в корне проекта не задана.
